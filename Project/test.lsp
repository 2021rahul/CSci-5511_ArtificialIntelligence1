(load "solution2.lsp")
(defun test ()
	(setq openedlist NIL)
	(setf openedlist (cons '(state1 17 10 7) openedlist))
	(setf openedlist (cons '(state2 15 10 5) openedlist))
	(setf openedlist (cons '(state3 16 10 6) openedlist))

	(sort (copy-list openedlist) #'> :key #'second)
)


(defun goalstate (N)
    (let ((lst NIL))
        (do ((i 1 (+ 1 i)))
            ((> i N))
            (setf lst (cons i lst)))
        (setf lst (cons 0 lst))
        (reverse lst)
    )
)

(defun test ()
	(setf goal (goalstate 8))
    ; (setf state (read_state start))
    ; (heuristic state goal)
    ; (setf coord (get_coordinates 8))
    ; (format t "~&A: ~s~%B: ~s~%" (nth 0 coord) (nth 1 coord))
    ; (get_index coord)
    ; (getdirections)
    ; (manhattan '(1 2) '(3 4))
    ; (get_new_state goal '(1 2) '(2 1))
    ; (check_valid_positions '(3 2))
    ; (get_neighbours goal)
    ; (setf newstates NIL)
    ; (setf goal (goalstate 8))
    ; (setf coord (get_coordinates (position 0 goal)))
    ; (setf newcoord (mapcar '+ coord '(-1 0)))
    ; (setf newstates (cons (get_new_state goal coord newcoord) newstates))
    ; (setf newcoord (mapcar '+ coord '(0 -1)))
    ; (setf newstates (cons (get_new_state goal coord newcoord) newstates))
    ; (list-to-string goal)
    (setq openedlist NIL)
    (setf openedlist (cons '(state1 17 10 7) openedlist))
    (setf openedlist (cons '(state2 15 10 5) openedlist))
    (setf openedlist (cons '(state3 16 10 6) openedlist))
    (setf ret_val (get_lowest_f_state openedlist))
    (setf lowest (car ret_val))
    (setf openedlist (cdr ret_val))
    )

(defun test_heuristic ()
	(setf goal '(1 2 3 4 5 6 7 8 0))
	(setf start '(0 1 3 4 2 5 7 8 6))
	(heuristic start goal)
)

(defun test_get_lowest_f_state ()
	(let (opened)
		(setf goal '(1 2 3 4 5 6 7 8 0))
		(setf start '(0 1 3 4 2 5 7 8 6))
		(setf opened (cons (evaluate_node goal goal 0) opened))
		(setf opened (cons (evaluate_node start goal 0) opened))
		(setf ret_val (get_lowest_f_state opened))
		(setf node (car ret_val))
		(setf opened (cdr ret_val))
	)
)


(defun is_solvable (state)
    (let ((count 0))
        (do ((i 0 (+ 1 i)))
            ((> i 8) count)
            (if (not (= (nth i state) 0))
                (do ((j i (+ 1 j)))
                    ((> j 8))
                    (if (and (not (= (nth j state) 0)) (> ( nth i state ) ( nth j state )))
                        (setf count (+ 1 count))
                    )
                )
            )
        )
        (evenp count)
    )
)

(defun test_solvable ()
	(setf start '(0 1 3 4 2 5 7 8 6))
	(is_solvable start)
)
